// 操作符
#include <stdio.h>

int main()
{
  /* code */
  // 按位(二进制位)取反

  int a = 0;
  int b = ~a;

  // 1010 => 0101
  printf("%d", b);
  return 0;
}

/**
 * chatGpt的答案
 * 在计算机中，原码、反码和补码都是用来表示有符号整数的编码方式。
 * 原码（Sign-Magnitude）：
 * 使用最高位表示符号位，其他位表示数值的绝对值。例如，正数 5 的原码为 00000101，负数 -5 的原码为 10000101。
 * 反码（One's Complement）：
 * 反码是对原码进行取反操作得到的，也就是将原码中的符号位保持不变，其他位取反。例如，正数 5 的反码为 00000101，负数 -5 的反码为 11111010。
 * 补码（Two's Complement）：
 * 补码是对反码加上 1 得到的。正数的补码和反码相同，负数的补码是其反码加 1。例如，正数 5 的补码为 00000101，负数 -5 的补码为 11111011。
 * 在 C 语言中，整数默认使用补码表示。对于给定的代码 int a = 0; int b = ~a;，首先将变量 a 初始化为 0，它的补码表示是 00000000。然后，对 a 进行按位取反操作 ~，即将每个二进制位的 0 变为 1，1 变为 0。取反后得到的结果是 11111111，按照补码的规则，该二进制补码被解释为 -1。
 * 因此，在 C 语言中，int b = ~a; 的结果是 -1。这是因为 ~ 运算符对整数进行按位取反，而整数使用补码表示，结果也是以补码形式解释的。
 *
 * 掘金的答案
 * 1、原码
 * 整数X的原码是指:其符号位为0表示正,为1表示负;其数值部分就是X的绝对值的二进制数。
 * X的原码通常用【X】原表示。如:
 * 【+100】原=01100100
 * 【+0】原=00000000
 * 【-100】原=11100100
 * 【-0】原=10000000
 * 注意:在原码中,零有两种表示形式。
 * 原码表示法简单易懂,与真值(带符号数本身)转换方便,只要符号还原即可,但当两个正数相减或不同符号数相加时,必须比较两个数哪个绝对值大,才能决定谁减谁,才能确定结果是正还是负,所以原码不便于加减运算。
 *
 * 2、反码
 * X的反码是指:对于正数,反码与原码相同;
 * 对于负数,符号位不变,其数值位X的绝对值取反(1变0,0变1)。X的反码通常用【X】反来表示。如
 * 【+100】反=01100100
 * 【+0】反=00000000
 * 【-100】反=10011011
 * 【-0】反=11111111
 * 注意:在反码中,零也有两种表示形式。
 * 反码运算也不方便,通常用来作为求补码的中间过渡。
 *
 * 3、补码
 * X的补码是指:对于正数,补码与原码相同;
 * 对于负数,符号位不变,其数值位X的绝对值取反后在最低位加1。X的补码通常用【X】补来表示,实际上,【X】补=【X】反+1。如:
 * 【+100】补=01100100
 * 【+0】补=00000000  
 * 【-100】补=10011100
 * 【-0】补=00000000
 * 注意:在补码中,零有唯一的编码,【+0】补=【-0】补=00000000。
 * 补码运算简单方便,符号位可以作为数据的一位参与运算,不必单独处理;二进制的减法可用其补码的加法来实现,简化了硬件电路。
 *
 *

 */
// 32位
// 11111111111111111111111111111111
// 33位
// 100000000000000000000000000000000
// 第33位的权重是 1 * 2 ^32
// 所以11111111111111111111111111111111等于1 * 2 ^32 - 1